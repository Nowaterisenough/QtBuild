# =============================================================================
# Qt Unified Release Workflow
# Collects all platform builds and creates a single comprehensive release
# =============================================================================

name: release-qt-unified

on:
  workflow_dispatch:
    inputs:
      qt_version:
        description: 'Qt Version to release'
        required: true
        default: '6.9.2'
        type: string
      platforms:
        description: 'Platforms to include (comma-separated)'
        required: true
        default: 'linux-gcc,linux-llvm,windows-msvc,windows-mingw,windows-llvm,wasm-emscripten'
        type: string
      release_notes:
        description: 'Additional release notes'
        required: false
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: true
        default: 'false'
        type: choice
        options:
        - 'true'
        - 'false'

env:
  QT_VERSION: ${{ github.event.inputs.qt_version || '6.9.2' }}
  PLATFORMS: ${{ github.event.inputs.platforms || 'linux-gcc,linux-llvm,windows-msvc,windows-mingw,windows-llvm,wasm-emscripten' }}
  ADDITIONAL_NOTES: ${{ github.event.inputs.release_notes || '' }}
  IS_PRERELEASE: ${{ github.event.inputs.prerelease == 'true' }}

jobs:
  collect-artifacts:
    runs-on: ubuntu-latest
    outputs:
      artifact-list: ${{ steps.find-artifacts.outputs.artifacts }}
      total-count: ${{ steps.find-artifacts.outputs.count }}
    steps:
      - name: Find recent build artifacts
        id: find-artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const qtVersion = '${{ env.QT_VERSION }}';
            const platforms = '${{ env.PLATFORMS }}'.split(',');
            
            // Get recent workflow runs for each platform
            const artifacts = [];
            const cutoffDate = new Date();
            cutoffDate.setHours(cutoffDate.getHours() - 168); // Look back 7 days (168 hours)
            
            for (const platform of platforms) {
              // Map platform names to actual workflow file names
              const workflowMap = {
                'windows-msvc': 'build-qt6-windows_x86_64_msvc_matrix',
                'windows-mingw': 'build-qt6-windows_x86_64_mingw_gcc_matrix',
                'windows-llvm': 'build-qt6-windows_x86_64_llvm_clang_matrix',
                'linux-gcc': 'build-qt6-linux_x86_64_gcc_matrix', 
                'linux-llvm': 'build-qt6-linux_x86_64_llvm_matrix',
                'wasm-emscripten': 'build-qt6-wasm32_emscripten_matrix'
              };
              
              const workflowName = workflowMap[platform.trim()];
              if (!workflowName) {
                console.log(`Warning: Unknown platform ${platform.trim()}`);
                continue;
              }
              console.log(`Looking for workflow: ${workflowName}`);
              
              try {
                const workflows = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: `${workflowName}.yml`,
                  status: 'completed',
                  conclusion: 'success',
                  per_page: 10
                });
                
                // Find the most recent successful run
                const recentRun = workflows.data.workflow_runs.find(run => 
                  new Date(run.created_at) > cutoffDate
                );
                
                if (recentRun) {
                  const runArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: recentRun.id
                  });
                  
                  // Filter artifacts by Qt version
                  const qtArtifacts = runArtifacts.data.artifacts.filter(artifact =>
                    artifact.name.includes(`qt${qtVersion}`)
                  );
                  
                  artifacts.push(...qtArtifacts.map(artifact => ({
                    name: artifact.name,
                    id: artifact.id,
                    size: artifact.size_in_bytes,
                    platform: platform,
                    run_id: recentRun.id
                  })));
                }
              } catch (error) {
                console.log(`Warning: Could not find workflow ${workflowName}: ${error.message}`);
              }
            }
            
            console.log(`Found ${artifacts.length} artifacts`);
            core.setOutput('artifacts', JSON.stringify(artifacts));
            core.setOutput('count', artifacts.length.toString());
            
            if (artifacts.length === 0) {
              core.setFailed('No recent build artifacts found. Please run the build workflows first.');
            }

  create-release:
    needs: collect-artifacts
    runs-on: ubuntu-latest
    if: needs.collect-artifacts.outputs.total-count > 0
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate release tag and notes
        id: release-info
        run: |
          # Generate release tag
          TAG_NAME="qt${{ env.QT_VERSION }}-$(date +'%Y%m%d%H%M%S')"
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          
          # Generate comprehensive release notes
          cat > release_notes.md << 'EOF'
          # Qt ${{ env.QT_VERSION }} - Unified Cross-Platform Release
          
          ## Overview
          This is a unified release containing Qt ${{ env.QT_VERSION }} builds for multiple platforms and compilers, all built from the same source with consistent configuration.
          
          ## Build Information
          - **Qt Version**: ${{ env.QT_VERSION }}
          - **Release Date**: $(date +'%Y-%m-%d %H:%M:%S UTC')
          - **Total Artifacts**: ${{ needs.collect-artifacts.outputs.total-count }}
          - **Included Platforms**: ${{ env.PLATFORMS }}
          - **Build Standard**: Qt Build Workflow Standards v1.0
          
          ## Supported Platforms & Compilers
          
          ### Linux x86_64
          - **GCC**: Versions 11, 12, 13, 14, and latest precompiled
          - **LLVM/Clang**: Versions 15-20 with libc++ and lld
          - **Architecture**: x86_64
          - **Build Environment**: WSL2 Ubuntu 24.04
          - **Package Format**: .tar.xz
          
          ### Windows x86_64
          - **MSVC**: Visual Studio 2019, 2022
          - **MinGW-GCC**: Versions 12.2.0-15.2.0 (UCRT)
          - **LLVM/Clang**: Version 21.1 with MSVC ABI
          - **Architecture**: x86_64
          - **Package Format**: .7z
          
          ### WebAssembly (WASM)
          - **Emscripten**: Versions 3.1.70, 4.0.13
          - **Host Compiler**: MinGW-GCC (cross-compilation)
          - **Target Architecture**: wasm32
          - **Package Format**: .tar.xz
          
          ## Standard Configurations
          
          All platforms include these standardized build configurations:
          
          ### Static Builds
          - `static_release`: Static linking, Release mode, optimized for distribution
          - `static_relwithdebinfo`: Static linking, Release with separate debug information
          
          ### Shared Builds
          - `shared_release`: Dynamic linking, Release mode, smaller executable size
          - `shared_debug`: Dynamic linking, Debug mode, full debugging symbols
          - `shared_relwithdebinfo`: Dynamic linking, Release with separate debug information
          
          ## Package Naming Convention
          All packages follow the standardized naming format:
          ```
          qt{VERSION}-{PLATFORM}-{ARCH}-{COMPILER}{VERSION}-{LINKTYPE}_{BUILDTYPE}.{EXT}
          ```
          
          Examples:
          - `qt6.9.2-linux-x86_64-gcc13-shared_release.tar.xz`
          - `qt6.9.2-windows-x86_64-msvc2022-static_relwithdebinfo.7z`
          - `qt6.9.2-wasm32-emscripten4.0.13-static_release.tar.xz`
          
          ## Installation Instructions
          
          ### Linux
          1. Download the appropriate `.tar.xz` file for your compiler
          2. Extract: `tar -xJf qt*.tar.xz`
          3. Set environment: `export QTDIR=/path/to/extracted/qt && export PATH=$QTDIR/bin:$PATH`
          
          ### Windows
          1. Download the appropriate `.7z` file for your compiler
          2. Extract using 7-Zip or similar tool
          3. Set environment: `set QTDIR=C:\path\to\extracted\qt` and add `%QTDIR%\bin` to PATH
          
          ### WebAssembly
          1. Download the `.tar.xz` file for your Emscripten version
          2. Extract: `tar -xJf qt*.tar.xz`
          3. Set environment with Emscripten active: `export QTDIR=/path/to/qt`
          
          ## Technical Features
          
          ### Build Optimizations
          - **C++ Standard**: C++20 across all platforms
          - **Memory Optimization**: Compiler flags tuned for GitHub Actions resource constraints
          - **Link-Time Optimization**: Disabled for build stability and faster compilation
          - **Debug Information**: Separate debug files available for production debugging
          
          ### Excluded Components
          - **QtWebEngine**: Excluded for faster builds and smaller packages
          - **Examples & Tests**: Excluded to reduce package size
          - **Documentation**: Available separately from Qt official sources
          
          ### Platform-Specific Notes
          - **Linux**: Built with memory-optimized flags, compatible with modern distributions
          - **Windows**: MSVC builds use latest Windows SDK, MinGW uses UCRT runtime
          - **WebAssembly**: Optimized for modern browsers, includes Qt Quick support
          
          ## Quality Assurance
          
          All builds in this release:
          - ✅ Follow Qt Build Workflow Standards v1.0
          - ✅ Use identical source code and configuration base
          - ✅ Pass automated build verification
          - ✅ Include standardized build reports
          - ✅ Use consistent naming and packaging
          
          EOF
          
          # Add user-provided release notes if any
          if [ -n '${{ env.ADDITIONAL_NOTES }}' ]; then
            echo "" >> release_notes.md
            echo "## Additional Notes" >> release_notes.md
            echo '${{ env.ADDITIONAL_NOTES }}' >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          echo "## Build Artifacts" >> release_notes.md
          echo "" >> release_notes.md
          echo "This release includes the following build artifacts:" >> release_notes.md
          echo "" >> release_notes.md

      - name: Download all artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = JSON.parse('${{ needs.collect-artifacts.outputs.artifact-list }}');
            const fs = require('fs');
            const path = require('path');
            
            // Create artifacts directory
            if (!fs.existsSync('release-artifacts')) {
              fs.mkdirSync('release-artifacts');
            }
            
            let totalSize = 0;
            let artifactList = [];
            
            for (const artifact of artifacts) {
              console.log(`Downloading artifact: ${artifact.name} (${Math.round(artifact.size / 1024 / 1024)}MB)`);
              
              try {
                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                  archive_format: 'zip'
                });
                
                const zipPath = path.join('release-artifacts', `${artifact.name}.zip`);
                fs.writeFileSync(zipPath, Buffer.from(download.data));
                
                // Extract the zip file (artifacts are usually single files in zip)
                const AdmZip = require('adm-zip');
                const zip = new AdmZip(zipPath);
                zip.extractAllTo('release-artifacts/', true);
                
                // Remove the zip file
                fs.unlinkSync(zipPath);
                
                totalSize += artifact.size;
                artifactList.push({
                  name: artifact.name,
                  platform: artifact.platform,
                  size: artifact.size
                });
                
              } catch (error) {
                console.log(`Warning: Failed to download ${artifact.name}: ${error.message}`);
              }
            }
            
            // Update release notes with artifact list
            let releaseNotes = fs.readFileSync('release_notes.md', 'utf8');
            
            artifactList
              .sort((a, b) => a.platform.localeCompare(b.platform) || a.name.localeCompare(b.name))
              .forEach(artifact => {
                const sizeMB = Math.round(artifact.size / 1024 / 1024);
                releaseNotes += `- **${artifact.name}** (${sizeMB}MB) - ${artifact.platform}\n`;
              });
            
            releaseNotes += `\n**Total Package Size**: ${Math.round(totalSize / 1024 / 1024)}MB\n`;
            
            fs.writeFileSync('release_notes.md', releaseNotes);
            
            console.log(`Successfully prepared ${artifactList.length} artifacts (${Math.round(totalSize / 1024 / 1024)}MB total)`);

      - name: Generate build configuration summary table
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = JSON.parse('${{ needs.collect-artifacts.outputs.artifact-list }}');
            const fs = require('fs');
            const path = require('path');
            
            // Download build reports and parse them
            const buildConfigs = new Map();
            
            for (const artifact of artifacts) {
              // Look for report artifacts from the same run
              try {
                console.log(`Looking for build reports from run ${artifact.run_id}`);
                
                const reportArtifacts = await github.rest.actions.listWorkflowRunArtifacts({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: artifact.run_id
                });
                
                // Find report artifacts (they follow pattern: report-{linktype}_{buildtype})
                const reports = reportArtifacts.data.artifacts.filter(a => 
                  a.name.startsWith('report-') && a.name.includes('_')
                );
                
                for (const report of reports) {
                  try {
                    const download = await github.rest.actions.downloadArtifact({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      artifact_id: report.id,
                      archive_format: 'zip'
                    });
                    
                    const AdmZip = require('adm-zip');
                    const zip = new AdmZip(Buffer.from(download.data));
                    const entries = zip.getEntries();
                    
                    if (entries.length > 0) {
                      const content = entries[0].getData().toString('utf8');
                      const config = parseQtConfigSummary(content);
                      if (config) {
                        const key = `${artifact.platform}-${report.name}`;
                        buildConfigs.set(key, {
                          platform: artifact.platform,
                          config: report.name.replace('report-', ''),
                          modules: config
                        });
                      }
                    }
                  } catch (error) {
                    console.log(`Warning: Failed to process report ${report.name}: ${error.message}`);
                  }
                }
              } catch (error) {
                console.log(`Warning: Failed to get reports for run ${artifact.run_id}: ${error.message}`);
              }
            }
            
            // Parse Qt config.summary format
            function parseQtConfigSummary(content) {
              const modules = {};
              const lines = content.split('\n');
              
              for (const line of lines) {
                const trimmed = line.trim();
                
                // Skip empty lines and section headers
                if (!trimmed || trimmed.endsWith(':')) continue;
                
                // Look for module/feature status lines with dots
                if (trimmed.includes('...')) {
                  const dotIndex = trimmed.lastIndexOf('...');
                  const module = trimmed.substring(0, dotIndex).trim();
                  const status = trimmed.substring(dotIndex + 3).trim();
                  
                  if (module && status) {
                    modules[module] = normalizeStatus(status);
                  }
                }
                // Also catch lines with just spaces before status (indented items)
                else if (trimmed.match(/^[A-Z].+\s+(yes|no|enabled|disabled|found|not found|\d+\.\d+|\w+)$/i)) {
                  const match = trimmed.match(/^(.+?)\s+(yes|no|enabled|disabled|found|not found|\d+\.\d+|\w+)$/i);
                  if (match) {
                    const module = match[1].trim();
                    const status = match[2].trim();
                    modules[module] = normalizeStatus(status);
                  }
                }
              }
              
              return modules;
            }
            
            function isImportantModule(module) {
              // Include all modules - don't filter anything
              return true;
            }
            
            function normalizeStatus(status) {
              const s = status.toLowerCase().trim();
              
              // Positive/enabled states
              if (s === 'yes' || s === 'enabled' || s === 'found' || s === 'true') return '✅';
              
              // Negative/disabled states  
              if (s === 'no' || s === 'disabled' || s === 'not found' || s === 'false') return '❌';
              
              // Runtime/system/external dependencies
              if (s.includes('runtime') || s.includes('system') || s.includes('using system')) return '🔄';
              
              // Version numbers (show as-is)
              if (s.match(/^\d+\.\d+/)) return s;
              
              // Lists/collections (like "Fusion Windows WindowsVista")
              if (s.includes(' ') && s.length > 10) return '📋';
              
              // Special values
              if (s === '<none>' || s === 'none') return '❌';
              if (s.includes('basic') || s.includes('minimal')) return '⚠️';
              
              // Everything else as-is but truncated if too long
              return s.length > 15 ? s.substring(0, 12) + '...' : s;
            }
            
            // Generate markdown table
            if (buildConfigs.size > 0) {
              // Get all unique modules across all configs
              const allModules = new Set();
              buildConfigs.forEach(config => {
                Object.keys(config.modules).forEach(module => allModules.add(module));
              });
              
              const sortedModules = Array.from(allModules).sort();
              
              // Generate table
              let table = '\n## Build Configuration Summary\n\n';
              table += '| Platform/Config | ' + sortedModules.join(' | ') + ' |\n';
              table += '|' + '-'.repeat(17) + '|' + sortedModules.map(() => ':-:').join('|') + '|\n';
              
              // Group by platform
              const platformGroups = new Map();
              buildConfigs.forEach((config, key) => {
                if (!platformGroups.has(config.platform)) {
                  platformGroups.set(config.platform, []);
                }
                platformGroups.set(config.platform, [...platformGroups.get(config.platform), config]);
              });
              
              platformGroups.forEach((configs, platform) => {
                configs.forEach(config => {
                  const row = [`**${platform}**<br/>\`${config.config}\``];
                  sortedModules.forEach(module => {
                    row.push(config.modules[module] || '-');
                  });
                  table += '| ' + row.join(' | ') + ' |\n';
                });
              });
              
              table += '\n**Legend:** ✅ Enabled | ❌ Disabled | 🔄 Runtime/System | 📋 Multiple Options | ⚠️ Basic/Minimal | - Not Applicable\n\n';
              
              // Append to release notes
              let releaseNotes = fs.readFileSync('release_notes.md', 'utf8');
              
              // Insert table before "Build Artifacts" section
              const insertPoint = releaseNotes.indexOf('## Build Artifacts');
              if (insertPoint !== -1) {
                releaseNotes = releaseNotes.slice(0, insertPoint) + table + releaseNotes.slice(insertPoint);
              } else {
                releaseNotes += table;
              }
              
              fs.writeFileSync('release_notes.md', releaseNotes);
              console.log(`Generated configuration table with ${sortedModules.length} modules for ${buildConfigs.size} configurations`);
            } else {
              console.log('No build configuration data found, skipping table generation');
            }

      - name: Create Unified Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release-info.outputs.tag_name }}
          name: Qt ${{ env.QT_VERSION }} - Cross-Platform Release
          body_path: release_notes.md
          draft: false
          prerelease: ${{ env.IS_PRERELEASE }}
          files: release-artifacts/**/*
          fail_on_unmatched_files: false
          make_latest: ${{ env.IS_PRERELEASE == 'false' }}

      - name: Clean up downloaded artifacts
        run: |
          echo "Release created successfully!"
          echo "Tag: ${{ steps.release-info.outputs.tag_name }}"
          echo "Artifacts: ${{ needs.collect-artifacts.outputs.total-count }}"
          rm -rf release-artifacts/