# =============================================================================
# Qt 6 Native Build Unified Release
# Creates unified releases for Windows and Linux native builds only
# =============================================================================

name: release-qt-native

on:
  workflow_dispatch:
    inputs:
      qt_version:
        description: 'Qt Version to release (e.g., 6.9.2)'
        required: true
        default: '6.9.2'
        type: string
      search_days:
        description: 'Search for artifacts from the last N days'
        required: true
        default: '7'
        type: string

env:
  QT_VERSION: ${{ github.event.inputs.qt_version }}
  SEARCH_DAYS: ${{ github.event.inputs.search_days || '7' }}

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download native build artifacts
        id: download
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // Native workflows only (no cross-compilation)
            const nativeWorkflows = {
              'windows-msvc': 'build-qt6-native-windows_x86_64_msvc_matrix',
              'windows-mingw': 'build-qt6-native-windows_x86_64_mingw_matrix', 
              'windows-llvm': 'build-qt6-native-windows_x86_64_llvm_matrix',
              'linux-gcc': 'build-qt6-native-linux_x86_64_gcc_matrix',
              'linux-llvm': 'build-qt6-native-linux_x86_64_llvm_matrix'
            };
            
            const qtVersion = process.env.QT_VERSION;
            const searchDays = parseInt(process.env.SEARCH_DAYS);
            const since = new Date(Date.now() - searchDays * 24 * 60 * 60 * 1000).toISOString();
            
            console.log(`Searching for Qt ${qtVersion} native build artifacts from the last ${searchDays} days`);
            
            let allArtifacts = [];
            let foundWorkflows = new Set();
            
            // Get workflow runs for each native workflow
            for (const [platform, workflowName] of Object.entries(nativeWorkflows)) {
              try {
                console.log(`Searching for workflow: ${workflowName}`);
                
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: `${workflowName}.yml`,
                  status: 'success',
                  created: `>${since}`,
                  per_page: 20
                });
                
                console.log(`Found ${runs.data.workflow_runs.length} successful runs for ${workflowName}`);
                
                for (const run of runs.data.workflow_runs) {
                  const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.id
                  });
                  
                  console.log(`Run ${run.id}: ${artifacts.data.artifacts.length} artifacts`);
                  
                  const qtArtifacts = artifacts.data.artifacts.filter(artifact => 
                    artifact.name.includes(qtVersion) && artifact.name.startsWith('qt')
                  );
                  
                  // Separate Qt packages and build reports
                  const qtPackages = qtArtifacts.filter(artifact => 
                    !artifact.name.startsWith('report-')
                  );
                  const buildReports = artifacts.data.artifacts.filter(artifact => 
                    artifact.name.startsWith('report-')
                  );
                  
                  // Download Qt packages
                  for (const artifact of qtPackages) {
                    console.log(`Found package: ${artifact.name} (${artifact.size_in_bytes} bytes)`);
                    
                    const download = await github.rest.actions.downloadArtifact({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      artifact_id: artifact.id,
                      archive_format: 'zip'
                    });
                    
                    const artifactPath = `${artifact.name}.zip`;
                    fs.writeFileSync(artifactPath, Buffer.from(download.data));
                    console.log(`Downloaded package: ${artifactPath}`);
                    
                    allArtifacts.push(artifact.name);
                    foundWorkflows.add(platform);
                  }
                  
                  // Download build reports
                  for (const artifact of buildReports) {
                    console.log(`Found report: ${artifact.name} (${artifact.size_in_bytes} bytes)`);
                    
                    const download = await github.rest.actions.downloadArtifact({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      artifact_id: artifact.id,
                      archive_format: 'zip'
                    });
                    
                    const artifactPath = `reports/${artifact.name}.zip`;
                    if (!fs.existsSync('reports')) {
                      fs.mkdirSync('reports', { recursive: true });
                    }
                    fs.writeFileSync(artifactPath, Buffer.from(download.data));
                    console.log(`Downloaded report: ${artifactPath}`);
                  }
                }
              } catch (error) {
                console.log(`Warning: Could not find workflow ${workflowName}: ${error.message}`);
              }
            }
            
            if (allArtifacts.length === 0) {
              core.setFailed(`No artifacts found for Qt ${qtVersion} in the last ${searchDays} days`);
              return;
            }
            
            console.log(`\nSUMMARY:`);
            console.log(`- Found artifacts: ${allArtifacts.length}`);
            console.log(`- Platforms covered: ${Array.from(foundWorkflows).join(', ')}`);
            console.log(`- Artifacts: ${allArtifacts.join(', ')}`);
            
            // Set outputs
            core.setOutput('artifacts_found', allArtifacts.length.toString());
            core.setOutput('platforms', Array.from(foundWorkflows).join(','));
            core.setOutput('artifact_list', allArtifacts.join('\n'));

      - name: Extract downloaded artifacts
        run: |
          echo "Extracting all downloaded artifact archives..."
          for zip_file in *.zip; do
            if [ -f "$zip_file" ]; then
              echo "Extracting: $zip_file"
              unzip -q "$zip_file" 
              rm "$zip_file"
            fi
          done
          
          echo "Extracting build reports..."
          if [ -d "reports" ]; then
            cd reports
            for zip_file in *.zip; do
              if [ -f "$zip_file" ]; then
                echo "Extracting report: $zip_file"
                unzip -q "$zip_file"
                rm "$zip_file"
              fi
            done
            cd ..
          fi
          
          echo "Available files after extraction:"
          find . -name "qt${{ env.QT_VERSION }}*" -type f | head -20
          echo "Available reports:"
          find reports -name "*.txt" -type f 2>/dev/null || echo "No reports found"

      - name: Parse build reports and generate configuration table
        id: parse_reports
        run: |
          echo "Parsing build reports to generate detailed configuration table..."
          
          # Initialize arrays and variables
          declare -A configs
          declare -A features
          declare -a build_configs
          declare -a all_features
          
          # Process each build report to collect configurations and features
          if [ -d "reports" ]; then
            for report in reports/*.txt; do
              if [ -f "$report" ]; then
                echo "Processing report: $report"
                
                # Extract configuration from filename: qt-build-report_shared_debug.txt
                basename_report=$(basename "$report")
                if [[ $basename_report =~ qt-build-report_([^_]+)_([^\.]+)\.txt ]]; then
                  link_type="${BASH_REMATCH[1]}"
                  build_type="${BASH_REMATCH[2]}"
                else
                  echo "Skipping file with unrecognized name: $basename_report"
                  continue
                fi
                
                # Determine platform and compiler
                platform="Unknown"
                compiler="Unknown"
                compiler_version=""
                
                while IFS= read -r line; do
                  if [[ "$line" =~ "Building for: win32-"* ]]; then
                    platform="Windows"
                  elif [[ "$line" =~ "Building for: linux-"* ]]; then
                    platform="Linux"
                  fi
                  
                  if [[ "$line" =~ "Compiler: gcc "([0-9.]+) ]]; then
                    compiler="GCC"
                    compiler_version="${BASH_REMATCH[1]}"
                  elif [[ "$line" =~ "Compiler: clang "([0-9.]+) ]]; then
                    if [[ "$line" =~ "mingw" ]]; then
                      compiler="LLVM-MinGW"
                    else
                      compiler="LLVM-Clang"
                    fi
                    compiler_version="${BASH_REMATCH[1]}"
                  elif [[ "$line" =~ "Microsoft.*Visual.*Studio" ]]; then
                    compiler="MSVC"
                    platform="Windows"
                  fi
                done < "$report"
                
                # Create config identifier
                config_name="${platform} ${compiler} ${link_type} ${build_type}"
                build_configs+=("$config_name")
                
                # Check if this is a Qt config.summary format report
                file_size=$(wc -c < "$report")
                feature_count=0
                
                
                # Skip small files (likely fallback reports without feature info)  
                if [[ $file_size -lt 1000 ]]; then
                  echo "Skipping $report - too small to contain Qt configuration summary ($file_size bytes)"
                  continue
                fi
                
                # Parse all features from Qt config.summary format
                # Add a newline at the end to ensure the last line is processed
                { cat "$report"; echo; } | while IFS= read -r line; do
                  # Match Qt summary format: "  Feature name .......................... yes/no"
                  if [[ "$line" =~ ^[[:space:]]+([A-Za-z][^.]*[A-Za-z0-9/\-+_[:space:]])[[:space:]]*[.]{3,}[[:space:]]+(yes|no)[[:space:]]*$ ]]; then
                    feature="${BASH_REMATCH[1]}"
                    state="${BASH_REMATCH[2]}"
                    
                    # Clean up feature name - remove trailing/leading spaces
                    feature=$(echo "$feature" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                    
                    if [[ -n "$feature" && -n "$state" ]]; then
                      ((feature_count++))
                      
                      if [[ "$state" == "yes" ]]; then
                        features["$feature,$config_name"]="✅"
                      else
                        features["$feature,$config_name"]="❌"
                      fi
                      
                      # Add to features list if not already present
                      found=false
                      for existing_feature in "${all_features[@]}"; do
                        if [[ "$existing_feature" == "$feature" ]]; then
                          found=true
                          break
                        fi
                      done
                      if [[ "$found" == "false" ]]; then
                        all_features+=("$feature")
                      fi
                    fi
                  fi
                done
                
                if [[ $feature_count -eq 0 ]]; then
                  echo "Warning: No Qt features found in $report - possibly not a config.summary format"
                else
                  echo "Successfully parsed $feature_count features from $report"
                fi
              fi
            done
          else
            echo "ERROR: No reports directory found - cannot generate configuration table without build reports"
            exit 1
          fi
          
          # Check if we have any valid configurations and features
          if [ ${#build_configs[@]} -eq 0 ]; then
            echo "ERROR: No valid build configurations found"
            exit 1
          fi
          
          if [ ${#all_features[@]} -eq 0 ]; then
            echo "WARNING: No Qt features parsed from build reports - generating basic configuration table"
            echo "This usually means reports are in fallback format (missing config.summary files)"
            
            # Generate basic configuration table with build information only
            echo "## Build Configuration Summary" > config_table.md
            echo "" >> config_table.md
            echo "**Note**: Detailed Qt feature information is not available for this release as the build reports did not contain configuration summaries. The table below shows the available build configurations." >> config_table.md
            echo "" >> config_table.md
            
            # Add basic config table
            if [ ${#build_configs[@]} -gt 0 ]; then
              {
                echo "| Configuration | Status |"
                echo "|---------------|--------|"
                for config in "${build_configs[@]}"; do
                  echo "| **$config** | ✅ Available |"
                done
              } >> config_table.md
              
              echo "" >> config_table.md
              echo "### Notes" >> config_table.md
              echo "- Build packages are available for download" >> config_table.md
              echo "- Detailed Qt feature information will be available in future releases when configuration summaries are properly generated" >> config_table.md
              echo "- For specific feature availability, please refer to Qt documentation or test the builds directly" >> config_table.md
            else
              echo "| Status | Message |" >> config_table.md
              echo "|--------|---------|" >> config_table.md
              echo "| ⚠️ Warning | No valid build configurations found |" >> config_table.md
            fi
          else
            # Generate detailed features table when we have feature data
            echo "## Build Configuration Matrix" > config_table.md
            echo "" >> config_table.md
            
            # Create table header - ensure proper formatting
            {
              echo -n "| Feature"
              for config in "${build_configs[@]}"; do
                echo -n " | $config"
              done
              echo " |"
            } >> config_table.md
            
            # Create separator line - ensure proper formatting
            {
              echo -n "|---------|"
              for config in "${build_configs[@]}"; do
                echo -n "---------|"
              done
              echo ""
            } >> config_table.md
            
            # Sort features for better organization
            IFS=$'\n'
            sorted_features=($(printf '%s\n' "${all_features[@]}" | sort))
            unset IFS
            
            # Create table rows - ensure proper formatting
            for feature in "${sorted_features[@]}"; do
              if [[ -n "$feature" ]]; then
                {
                  echo -n "| **$feature**"
                  for config in "${build_configs[@]}"; do
                    status="${features["$feature,$config"]:-"❓"}"
                    echo -n " | $status"
                  done
                  echo " |"
                } >> config_table.md
              fi
            done
            
            # Add build info summary
            echo "" >> config_table.md
            echo "### Legend" >> config_table.md
            echo "- ✅ = Enabled/Supported" >> config_table.md
            echo "- ❌ = Disabled/Not Available" >> config_table.md
            echo "- ❓ = Status Unknown" >> config_table.md
            echo "" >> config_table.md
            echo "### Build Details" >> config_table.md
            
            # Add detailed build information
            for config in "${build_configs[@]}"; do
              echo "- **$config**: Available as downloadable package" >> config_table.md
            done
          fi
          
          echo ""
          echo "Generated detailed configuration matrix:"
          echo "Found ${#all_features[@]} features and ${#build_configs[@]} build configurations"
          echo "Features: ${all_features[*]}"
          echo "Build configs: ${build_configs[*]}"
          echo ""
          echo "Configuration table preview:"
          head -20 config_table.md
          echo "... (full table includes ${#all_features[@]} features)"

      - name: Generate release notes
        id: release_notes
        run: |
          QT_VERSION="${{ env.QT_VERSION }}"
          PLATFORMS="${{ steps.download.outputs.platforms }}"
          ARTIFACT_COUNT="${{ steps.download.outputs.artifacts_found }}"
          
          # Generate simplified release notes with only configuration table
          cat > release_notes.md << EOF
          # Qt ${{ env.QT_VERSION }} Build Configuration Matrix
          
          EOF
          
          # Insert the generated configuration table
          cat config_table.md >> release_notes.md
          
          echo "Release notes generated:"
          cat release_notes.md

      - name: Generate release tag
        id: release_tag
        run: echo "tag=qt${{ env.QT_VERSION }}-native-$(date +%Y%m%d-%H%M)" >> $GITHUB_OUTPUT

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release_tag.outputs.tag }}
          name: Qt ${{ env.QT_VERSION }} Native Builds
          body_path: release_notes.md
          files: qt${{ env.QT_VERSION }}*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Release Summary
        run: |
          echo "## ✅ Native Release Created Successfully"
          echo "- **Qt Version**: ${{ env.QT_VERSION }}"
          echo "- **Platforms**: ${{ steps.download.outputs.platforms }}" 
          echo "- **Artifacts**: ${{ steps.download.outputs.artifacts_found }}"
          echo ""
          echo "Cross-compilation builds should be released separately using 'release-qt-cross' workflow."